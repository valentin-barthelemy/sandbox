# -*- coding: utf-8 -*-
"""Black scholes test.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ge_WW1ka6b1DCGsLxwX4lZjYB0KGrMCG
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm
from scipy.optimize import brentq

plt.style.use("seaborn-v0_8-whitegrid")

def _d1_d2(S, K, r, q, sigma, T):
    """d1 et d2 de Black-Scholes (dividende continu q)."""
    if sigma <= 0 or T <= 0:
        raise ValueError("sigma et T doivent √™tre > 0")
    vsqrt = sigma * np.sqrt(T)
    d1 = (np.log(S / K) + (r - q + 0.5 * sigma**2) * T) / vsqrt
    d2 = d1 - vsqrt
    return d1, d2

def bs_call(S, K, r, sigma, T, q=0.0):
    """Prix du call europ√©en BSM avec dividende continu q."""
    d1, d2 = _d1_d2(S, K, r, q, sigma, T)
    return S * np.exp(-q*T) * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2)

def bs_put(S, K, r, sigma, T, q=0.0):
    """Prix du put europ√©en BSM via parit√© put-call."""
    c = bs_call(S, K, r, sigma, T, q)
    return c - S*np.exp(-q*T) + K*np.exp(-r*T)

def greeks_call(S, K, r, sigma, T, q=0.0):
    """Greeks du call europ√©en (Delta, Gamma, Theta, Vega, Rho)."""
    d1, d2 = _d1_d2(S, K, r, q, sigma, T)
    Nd1, Nd2 = norm.cdf(d1), norm.cdf(d2)
    nd1 = norm.pdf(d1)
    disc_r = np.exp(-r*T)
    disc_q = np.exp(-q*T)

    delta = disc_q * Nd1
    gamma = disc_q * nd1 / (S * sigma * np.sqrt(T))
    vega  = S * disc_q * nd1 * np.sqrt(T)                # par % = vega/100
    theta = (-S*disc_q*nd1*sigma/(2*np.sqrt(T))
             + q*S*disc_q*Nd1 - r*K*disc_r*Nd2)         # par an
    rho   = K*T*disc_r*Nd2

    return dict(delta=delta, gamma=gamma, theta=theta, vega=vega, rho=rho)

def greeks_put(S, K, r, sigma, T, q=0.0):
    """Greeks du put europ√©en."""
    d1, d2 = _d1_d2(S, K, r, q, sigma, T)
    Nd1m, Nd2m = norm.cdf(d1)-1, norm.cdf(d2)-1
    nd1 = norm.pdf(d1)
    disc_r = np.exp(-r*T)
    disc_q = np.exp(-q*T)

    delta = disc_q * (Nd1m)
    gamma = disc_q * nd1 / (S * sigma * np.sqrt(T))
    vega  = S * disc_q * nd1 * np.sqrt(T)
    theta = (-S*disc_q*nd1*sigma/(2*np.sqrt(T))
             - q*S*disc_q*norm.cdf(-d1) + r*K*disc_r*norm.cdf(-d2))
    rho   = -K*T*disc_r*norm.cdf(-d2)

    return dict(delta=delta, gamma=gamma, theta=theta, vega=vega, rho=rho)

def implied_vol_call(target_price, S, K, r, T, q=0.0, sigma_lo=1e-6, sigma_hi=5.0):
    """IV du call par Brent. Renvoie np.nan si pas de solution."""
    def f(s): return bs_call(S, K, r, s, T, q) - target_price
    try:
        # V√©rifier que la racine est bien encadr√©e
        f_lo, f_hi = f(sigma_lo), f(sigma_hi)
        if f_lo * f_hi > 0:
            return np.nan
        return brentq(f, sigma_lo, sigma_hi, maxiter=100, xtol=1e-12)
    except Exception:
        return np.nan

def mc_call_rn(S, K, r, sigma, T, q=0.0, n_paths=200_000, antithetic=True, seed=42):
    """Prix call par Monte Carlo en monde risque-neutre (validation)."""
    rng = np.random.default_rng(seed)
    n = n_paths//2 if antithetic else n_paths
    Z = rng.standard_normal(n)
    if antithetic:
        Z = np.concatenate([Z, -Z])
    drift = (r - q - 0.5*sigma**2) * T
    ST = S * np.exp(drift + sigma*np.sqrt(T) * Z)
    payoff = np.maximum(ST - K, 0.0)
    return np.exp(-r*T) * payoff.mean()

# Param√®tres de base (modifie-les librement)
S, K = 99, 100.0
r, q = 0.1, 0.00
sigma, T = 0.20, 1.0

call = bs_call(S, K, r, sigma, T, q)
put  = bs_put (S, K, r, sigma, T, q)
gc   = greeks_call(S, K, r, sigma, T, q)
gp   = greeks_put (S, K, r, sigma, T, q)
call_mc = mc_call_rn(S, K, r, sigma, T, q, n_paths=100_000)

print(f"Call BSM = {call:.4f} | Put BSM = {put:.4f}")
print(f"Call MC  = {call_mc:.4f} (validation)")
print("Greeks Call:", {k: round(v, 4) for k,v in gc.items()})
print("Greeks Put :", {k: round(v, 4) for k,v in gp.items()})

# Test IV: on retrouve sigma √† partir du prix
iv = implied_vol_call(call, S, K, r, T, q)
print(f"IV (retrouv√©e) = {iv:.4%}")

fig, ax = plt.subplots(1, 2, figsize=(12,4))

# Prix vs S
S_grid = np.linspace(50, 150, 101)
prices = [bs_call(s, K, r, sigma, T, q) for s in S_grid]
ax[0].plot(S_grid, prices)
ax[0].set_title("Call BSM en fonction de S")
ax[0].set_xlabel("S")
ax[0].set_ylabel("Prix")

# Prix vs sigma
sig_grid = np.linspace(0.01, 0.8, 101)
prices_sig = [bs_call(S, K, r, s, T, q) for s in sig_grid]
ax[1].plot(sig_grid, prices_sig)
ax[1].set_title("Call BSM en fonction de œÉ")
ax[1].set_xlabel("œÉ")
ax[1].set_ylabel("Prix")

plt.tight_layout()
plt.show()

def simulate_path_gbm(S0, mu, sigma, T, steps, q=0.0, seed=None):
    """Un chemin GBM discret (Euler exact sur logS)."""
    rng = np.random.default_rng(seed)
    dt = T/steps
    Z = rng.standard_normal(steps)
    logS = np.log(S0) + np.cumsum((mu - q - 0.5*sigma**2)*dt + sigma*np.sqrt(dt)*Z)
    S = np.concatenate([[S0], np.exp(logS)])
    return S

def delta_hedge_error_one_path(S0, K, r, sigma_model, sigma_real, T, steps, q=0.0, mu_real=None, seed=1):
    """Erreur de couverture delta sur un chemin (œÉ_model pour la couverture, œÉ_real pour le chemin)."""
    if mu_real is None:
        mu_real = r  # par d√©faut monde RN
    dt = T/steps

    # Prix initial et position initiale
    S_path = simulate_path_gbm(S0, mu_real, sigma_real, T, steps, q, seed=seed)
    V0 = bs_call(S0, K, r, sigma_model, T, q)
    delta = greeks_call(S0, K, r, sigma_model, T, q)['delta']
    shares = -delta                       # on vend 1 call, on ach√®te -Œî actions pour couvrir
    cash = V0 + shares * S0               # cash restant (sur compte r√©mun√©r√©)

    # Rebalancing
    for i in range(1, steps+1):
        t = i*dt
        T_remain = max(T - t, 1e-12)
        S = S_path[i]

        # Accru du cash
        cash *= np.exp(r*dt)

        # Nouvelle delta (mod√®le)
        delta_new = greeks_call(S, K, r, sigma_model, T_remain, q)['delta']
        # Ajustement d'actions
        d_shares = -(delta_new - (-shares))  # quantit√© √† acheter (car shares = -delta)
        cash -= d_shares * S
        shares -= d_shares

    # √Ä maturit√© : rachat du payoff du call
    ST = S_path[-1]
    payoff = max(ST - K, 0.0)
    pnl = cash + shares*ST - payoff
    return pnl, S_path

# Exemple
S0, K, r, q, T = 100, 100, 0.03, 0.0, 1.0
sigma_model = 0.2   # volatilit√© utilis√©e pour calculer Œî
sigma_real  = 0.2   # volatilit√© r√©alisant le chemin
steps = 252

pnl, path = delta_hedge_error_one_path(S0, K, r, sigma_model, sigma_real, T, steps, q, mu_real=r, seed=123)
print(f"PNL de couverture (1 chemin) = {pnl:.4f}")

plt.figure(figsize=(6,3))
plt.plot(path)
plt.title("Chemin simul√© S_t")
plt.xlabel("Pas")
plt.ylabel("S")
plt.show()

def hedge_error_distribution(n_paths=1000, seed=7):
    rng = np.random.default_rng(seed)
    pnls = []
    for j in range(n_paths):
        pnl, _ = delta_hedge_error_one_path(
            S0=100, K=100, r=0.03, sigma_model=0.20, sigma_real=0.20,
            T=1.0, steps=252, q=0.0, mu_real=0.03, seed=rng.integers(0, 10_000_000)
        )
        pnls.append(pnl)
    pnls = np.array(pnls)
    return pnls

pnls = hedge_error_distribution(n_paths=1000)
print(f"Erreur moyenne ‚âà {pnls.mean():.4f} | √©cart-type ‚âà {pnls.std():.4f}")

plt.figure(figsize=(6,3))
plt.hist(pnls, bins=40, alpha=0.7, edgecolor='k')
plt.title("Distribution des erreurs de couverture (Œî discret, 252 pas)")
plt.xlabel("PNL")
plt.ylabel("Fr√©quence")
plt.show()

import numpy as np
import matplotlib.pyplot as plt

def plot_price_vs_one_param(
    S=100, K=100, r=0.03, q=0.0, sigma=0.20, T=1.0,
    var_on_x="S", x_min=None, x_max=None, n=201
):
    base = dict(S=S, K=K, r=r, q=q, sigma=sigma, T=T)
    # Plages par d√©faut raisonnables
    defaults = {
        "S": (0.5*S, 1.5*S),
        "K": (0.5*K, 1.5*K),
        "sigma": (0.05, 0.80),
        "T": (0.05, max(0.25, 2.0)),
        "r": (0.0, max(0.05, 0.10)),
        "q": (0.0, max(0.05, 0.10)),
    }
    x_lo, x_hi = defaults[var_on_x]
    if x_min is not None: x_lo = x_min
    if x_max is not None: x_hi = x_max

    xs = np.linspace(x_lo, x_hi, n)
    calls, puts = [], []

    for x in xs:
        p = base.copy()
        p[var_on_x] = x
        c = bs_call(p["S"], p["K"], p["r"], p["sigma"], p["T"], p["q"])
        calls.append(c)
        puts.append(bs_put(p["S"], p["K"], p["r"], p["sigma"], p["T"], p["q"]))

    plt.figure(figsize=(7,4))
    plt.plot(xs, calls, label="Call BSM", lw=2)
    plt.plot(xs, puts,  label="Put BSM",  lw=2, ls="--")
    plt.title(f"Prix BSM en fonction de {var_on_x}")
    plt.xlabel(var_on_x)
    plt.ylabel("Prix")
    plt.legend()
    plt.grid(True)
    plt.show()

# üîß Exemple : Prix vs S
plot_price_vs_one_param(S=100, K=100, r=0.03, q=0.0, sigma=0.20, T=1.0,
                        var_on_x="S", x_min=50, x_max=150)

!pip -q install ipywidgets
from ipywidgets import interact, FloatSlider, Dropdown, VBox, HBox, IntSlider

def ui_plot():
    S = FloatSlider(value=100.0, min=20, max=300, step=1, description='S')
    K = FloatSlider(value=100.0, min=20, max=300, step=1, description='K')
    r = FloatSlider(value=0.03, min=0.0, max=0.15, step=0.001, readout_format='.3f', description='r')
    q = FloatSlider(value=0.00, min=0.0, max=0.10, step=0.001, readout_format='.3f', description='q')
    sigma = FloatSlider(value=0.20, min=0.05, max=0.80, step=0.005, readout_format='.3f', description='sigma')
    T = FloatSlider(value=1.0, min=0.05, max=3.0, step=0.01, readout_format='.2f', description='T')

    var_on_x = Dropdown(options=["S","K","sigma","T","r","q"], value="S", description="X-axis")
    x_min = FloatSlider(value=50.0, min=0.0, max=500.0, step=1.0, description='x_min')
    x_max = FloatSlider(value=150.0, min=0.0, max=500.0, step=1.0, description='x_max')

    def _update(S, K, r, q, sigma, T, var_on_x, x_min, x_max):
        plot_price_vs_one_param(S, K, r, q, sigma, T, var_on_x, x_min, x_max)

        # Affiche aussi le prix et quelques Greeks au point "base"
        c = bs_call(S, K, r, sigma, T, q)
        p = bs_put (S, K, r, sigma, T, q)
        gc = greeks_call(S, K, r, sigma, T, q)
        print(f"Call={c:.4f}  Put={p:.4f} | Œî={gc['delta']:.4f}  Œì={gc['gamma']:.6f}  ŒΩ={gc['vega']:.4f}  Œò={gc['theta']:.4f}  œÅ={gc['rho']:.4f}")

    return interact(_update, S=S, K=K, r=r, q=q, sigma=sigma, T=T,
                    var_on_x=var_on_x, x_min=x_min, x_max=x_max)

ui_plot();

from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 (needed for 3D)
import matplotlib.pyplot as plt

def surface_call_vs_S_sigma(K=100, r=0.03, q=0.0, T=1.0,
                            S_min=50, S_max=150, sig_min=0.05, sig_max=0.8, nS=80, nSig=60):
    S_grid = np.linspace(S_min, S_max, nS)
    sig_grid = np.linspace(sig_min, sig_max, nSig)
    SS, SIG = np.meshgrid(S_grid, sig_grid)

    Z = np.empty_like(SS, dtype=float)
    for i in range(SIG.shape[0]):
        for j in range(SIG.shape[1]):
            Z[i,j] = bs_call(SS[i,j], K, r, SIG[i,j], T, q)

    fig = plt.figure(figsize=(8,6))
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_surface(SS, SIG, Z, cmap='viridis', linewidth=0, antialiased=True)
    ax.set_title("Surface: Call BSM vs S et œÉ (K, r, q, T fix√©s)")
    ax.set_xlabel("S")
    ax.set_ylabel("œÉ")
    ax.set_zlabel("Prix du call")
    plt.show()

# Exemple
surface_call_vs_S_sigma(K=100, r=0.03, q=0.0, T=1.0)

def plot_greeks_vs_S(K=100, r=0.03, q=0.0, sigma=0.20, T=1.0, S_min=50, S_max=150, n=201):
    Sx = np.linspace(S_min, S_max, n)
    d,g,t,v,rh = [],[],[],[],[]
    for s in Sx:
        gg = greeks_call(s, K, r, sigma, T, q)
        d.append(gg['delta']); g.append(gg['gamma']); t.append(gg['theta']); v.append(gg['vega']); rh.append(gg['rho'])

    fig, ax = plt.subplots(2,2, figsize=(10,6))
    ax[0,0].plot(Sx, d);  ax[0,0].set_title("Delta (call)")
    ax[0,1].plot(Sx, g);  ax[0,1].set_title("Gamma")
    ax[1,0].plot(Sx, v);  ax[1,0].set_title("Vega")
    ax[1,1].plot(Sx, t);  ax[1,1].set_title("Theta (par an)")
    for a in ax.ravel(): a.grid(True); a.set_xlabel("S")
    plt.tight_layout(); plt.show()

plot_greeks_vs_S(K=100, r=0.03, q=0.0, sigma=0.20, T=1.0, S_min=60, S_max=140)

