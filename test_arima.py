# -*- coding: utf-8 -*-
"""Test ARIMA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b5OxMqfygvnP8f-VV0CTK5qiNVvykgYR
"""

from __future__ import print_function
import os
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima_model import ARIMA
import statsmodels.api as sm
import statsmodels.tsa.api as smtsa

from google.colab import files
files.upload()

djia_df = pd.read_excel('DJIA_Jan2016_Dec2016.xlsx')
djia_df.head()

def plotds(xt, nlag=30, fig_size=(12, 10)):
    if not isinstance(xt, pd.Series):
         xt = pd.Series(xt)
    plt.figure(figsize=fig_size)
    layout = (2, 2)

    # Assign axes
    ax_xt = plt.subplot2grid(layout, (0, 0), colspan=2)
    ax_acf= plt.subplot2grid(layout, (1, 0))
    ax_pacf = plt.subplot2grid(layout, (1, 1))

    # Plot graphs
    xt.plot(ax=ax_xt)
    ax_xt.set_title('Time Series')
    plot_acf(xt, lags=50, ax=ax_acf)
    plot_pacf(xt, lags=50, ax=ax_pacf)
    plt.tight_layout()
    return None

djia_df['Date'] = pd.to_datetime(djia_df['Date'], '%Y-%m-%d')
djia_df.index = djia_df['Date']
djia_df.drop('Date', axis=1, inplace=True)

djia_df.head()

djia_df=djia_df.dropna()
plotds(djia_df['Close'], nlag=50)

mean1, mean2 =djia_df.iloc[:125].Close.mean(), djia_df.iloc[125:].Close.mean()
var1, var2 = djia_df.iloc[:125].Close.var(), djia_df.iloc[125:].Close.var()
print('mean1=%f, mean2=%f' % (mean1, mean2))
print('variance1=%f, variance2=%f' % (var1, var2))

from statsmodels.tsa.stattools import adfuller
adf_result= adfuller(djia_df.Close.tolist())
print('ADF Statistic: %f' % adf_result[0])
print('p-value: %f' % adf_result[1])

sm.qqplot(djia_df['Close'], line='s')

first_order_diff = djia_df['Close'].diff(1).dropna()
fig, ax = plt.subplots(2, sharex=True)
fig.set_size_inches(5.5, 5.5)
djia_df['Close'].plot(ax=ax[0], color='b')
ax[0].set_title('Close values of DJIA during Jan 2016-Dec 2016')
first_order_diff.plot(ax=ax[1], color='r')
ax[1].set_title('First-order differences of DJIA during Jan 2016-Dec 2016')

plotds(first_order_diff, nlag=50)
adf_result= adfuller(first_order_diff)
print('ADF Statistic: %f' % adf_result[0])
print('p-value: %f' % adf_result[1])



# Fit the ARIMA model
# Correcting the order based on previous attempts and common practice
arma_obj = smtsa.ARIMA(djia_df['Close'].tolist(), order=(1, 1, 1)).fit()

# Make predictions
predictions = arma_obj.predict()
display(predictions)

# Calculate residuals
residuals = djia_df['Close'] - predictions

# Plot residuals
plt.figure(figsize=(10, 6))
plt.plot(residuals)
plt.title('ARIMA Model Residuals')
plt.xlabel('Date')
plt.ylabel('Residuals')
plt.grid(True)
plt.show()

"""## ARIMA Model Implementation Summary

Here's a summary of the steps we followed to implement and use the ARIMA model for forecasting the DJIA Close values:

1.  **Data Loading and Preparation**: We loaded the DJIA data from the provided Excel file and prepared it for time series analysis by setting the 'Date' column as the index and handling missing values.
2.  **Data Visualization**: We visualized the time series data to understand its patterns, including trends and potential non-stationarity.
3.  **Stationarity Check**: We used the Augmented Dickey-Fuller (ADF) test to check for stationarity in the original time series. The results indicated that the series was not stationary.
4.  **Differencing**: To address the non-stationarity, we applied first-order differencing to the 'Close' values.
5.  **ACF and PACF Plots**: We plotted the Autocorrelation Function (ACF) and Partial Autocorrelation Function (PACF) of the differenced series to help determine the appropriate order (p, d, q) for the ARIMA model.
6.  **Model Fitting**: Based on the analysis and common practices, we fitted an ARIMA(1, 1, 1) model to the data.
7.  **Forecasting**: We used the fitted ARIMA model to generate predictions for the time series.

This process provides a basic implementation of an ARIMA model for time series forecasting. Further steps could involve model evaluation (analyzing residuals, checking for autocorrelation in residuals) and refining the model order for better performance.
"""