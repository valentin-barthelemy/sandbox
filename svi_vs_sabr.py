# -*- coding: utf-8 -*-
"""svi vs sabr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_2ljUJJCJ_YVKABS0JWXMsXu0_cy5yYL
"""

import numpy as np
import matplotlib.pyplot as plt

# ==========================
# 1) Paramètres de base
# ==========================

F = 100.0      # Forward ou spot (approx) du sous-jacent
T = 1.0        # Maturité (en années)

# --- Paramètres SABR (exemple typique) ---
alpha = 0.25   # vol "de départ"
beta = 0.7     # 0 = normal, 1 = log-normal
rho = -0.3     # corrélation spot-vol
nu = 0.6       # vol-of-vol

# --- Paramètres SVI (pour UNE maturité) ---
# w(k) = a + b * [ rho * (k - m) + sqrt((k - m)^2 + sigma^2) ]
svi_a = 0.04
svi_b = 0.2
svi_rho = -0.5
svi_m = 0.0
svi_sigma = 0.3

# ==========================
# 2) Fonction SABR (formule de Hagan)
# ==========================

def sabr_implied_vol(F, K, T, alpha, beta, rho, nu):
    """
    Volatilité implicite de Black selon la formule approchée de Hagan pour SABR.
    F : forward
    K : strike (scalaire ou array)
    T : maturité
    alpha, beta, rho, nu : paramètres SABR
    """
    K = np.asarray(K, dtype=float)

    # Gestion d'un K très proche de F (cas ATM)
    eps = 1e-07
    FK = F * K
    logFK = np.log(F / K)

    # Terme commun de correction en T
    # (cf. Hagan et al. 2002)
    zeta = (1 - beta)
    # Pour éviter F^0 quand beta=1
    FK_beta = (FK) ** (zeta / 2.0)

    # Cas général : K != F
    z = (nu / alpha) * FK_beta * logFK
    sqrt_term = np.sqrt(1 - 2 * rho * z + z**2)
    x_z = np.log((sqrt_term + z - rho) / (1 - rho))

    # Dénominateur "log-moneyness adjusted"
    logFK2 = logFK**2
    logFK4 = logFK**4
    A = alpha / (FK_beta * (1 + (zeta**2 / 24.0) * logFK2 + (zeta**4 / 1920.0) * logFK4))

    # Correction en temps
    B1 = (zeta**2 / 24.0) * (alpha**2) / (FK**zeta)
    B2 = (rho * zeta * nu * alpha) / (4.0 * FK_beta)
    B3 = ((2 - 3 * rho**2) * nu**2) / 24.0
    B = 1 + T * (B1 + B2 + B3)

    # Cas K très proche de F : utiliser limite z/x_z → 1
    vol = np.empty_like(K)
    mask_atm = np.abs(K - F) < eps
    mask_not_atm = ~mask_atm

    # Cas non-ATM
    vol[mask_not_atm] = A[mask_not_atm] * (z[mask_not_atm] / x_z[mask_not_atm]) * B[mask_not_atm]

    # Cas ATM (approximation spécifique Hagan)
    if np.any(mask_atm):
        # Pour K = F, logFK = 0, z = 0, donc on prend la limite
        # sigma_ATM ≈ alpha / (F^{1 - beta}) * [ 1 + T * (B1_ATM + B2_ATM + B3) ]
        FK_ATM = F * F
        FK_beta_ATM = FK_ATM ** (zeta / 2.0)
        B1_ATM = (zeta**2 / 24.0) * (alpha**2) / (FK_ATM**zeta)
        B2_ATM = (rho * zeta * nu * alpha) / (4.0 * FK_beta_ATM)
        B_ATM = 1 + T * (B1_ATM + B2_ATM + B3)

        vol_atm = (alpha / FK_beta_ATM) * B_ATM
        vol[mask_atm] = vol_atm

    return vol

# ==========================
# 3) Fonction SVI (statique)
# ==========================

def svi_implied_vol(F, K, T, a, b, rho, m, sigma):
    """
    Vol implicite de Black selon le sourire SVI (une maturité).
    On modélise la variance totale : w(k) = sigma_imp^2 * T
    k = ln(K / F).
    """
    K = np.asarray(K, dtype=float)
    k = np.log(K / F)

    w = a + b * (rho * (k - m) + np.sqrt((k - m)**2 + sigma**2))
    # w = variance totale => vol = sqrt(w / T)
    w = np.maximum(w, 1e-10)  # éviter valeurs négatives numériques
    sigma_imp = np.sqrt(w / T)
    return sigma_imp

# ==========================
# 4) Construction du grille de strikes et calcul des smiles
# ==========================

# Strikes de 60% à 140% du forward
strike_min = 0.6 * F
strike_max = 1.4 * F
n_strikes = 80

strikes = np.linspace(strike_min, strike_max, n_strikes)

# Smile SABR
vol_sabr = sabr_implied_vol(F, strikes, T, alpha, beta, rho, nu)

# Smile SVI
vol_svi = svi_implied_vol(F, strikes, T, svi_a, svi_b, svi_rho, svi_m, svi_sigma)

# ==========================
# 5) Plot comparatif
# ==========================

plt.figure(figsize=(10, 6))
plt.plot(strikes, vol_sabr, label='SABR (Hagan)', linewidth=2)
plt.plot(strikes, vol_svi, label='SVI (statique)', linestyle='--', linewidth=2)

plt.axvline(F, color='grey', linestyle=':', linewidth=1)
plt.text(F, min(vol_sabr.min(), vol_svi.min()), '  ATM', va='bottom', color='grey')

plt.title("Comparaison du smile SABR vs SVI (même maturité)")
plt.xlabel("Strike K")
plt.ylabel("Volatilité implicite σ(K,T)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

