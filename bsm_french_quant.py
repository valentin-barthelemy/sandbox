# -*- coding: utf-8 -*-
"""BSM French quant.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RKSqN5sBQvLhrB_M8CNpTVT3b_HYeyzD
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm

K= 100
mu = 0.8
S0 = 100
sigma= 0.5
r= 0.03
T =1
n_sim = 100
n_time = 252
dt = 1/252
type_ = 'C'

def get_bsm_price(sigma, r, S0, K, T, n_sim, n_time, type_):
  d1 = (np.log(S0/K) + (r + sigma**2/2)*T)/(sigma*np.sqrt(T))
  d2 = d1 -sigma*np.sqrt(T)

  if type_ == 'C':
    price = S0 * norm.cdf(d1) - K * np.exp(-r*T) * norm.cdf(d2)

  else:
    price = K * np.exp(-r*T) * norm.cdf(-d2) - S0 * norm.cdf(-d1)

  return price

bsm_price = get_bsm_price(sigma, r, S0, K, T, n_sim, n_time, type_)
bsm_price

def get_gbms (mu, sigma, n_sim, n_time, S0,dt):
  gbms = np.ones(shape = (n_time, n_sim))*S0
  W_t = np.random.standard_normal(size=gbms.shape)
  for i in range (1, gbms.shape[0]):
    gbms[i] = gbms[i-1]*np.exp((mu-sigma**2/2)*dt + sigma* W_t[i]*np.sqrt(dt))

  return gbms

plt.plot(get_gbms(r, sigma, n_sim, n_time, S0, dt))
plt.show()

gbms = get_gbms(mu, sigma, n_sim, n_time, S0, dt)
t = np.linspace(0, T, n_time)
n_to_plot = n_sim
plt.figure(figsize=(10,6))
plt.plot(t, gbms[:, :n_to_plot])             # plusieurs paths
plt.plot(t, gbms.mean(axis=1), linewidth=3, label='Moyenne simulée')
plt.plot(t, S0*np.exp(mu*t), linewidth=2, linestyle='--', label='Moyenne théorique $S_0 e^{\\mu t}$')
plt.title("Trajectoires GBM")
plt.xlabel("Temps (années)")
plt.ylabel("Prix")
plt.legend()
plt.show()

dt = 1
time_in_days = 2
n_sim = 1000000

def get_monte_carlo_price(mu, sigma, n_sim, n_time, S0, dt, r, T, K, type_):
  S = get_gbms(mu=r, sigma=sigma, n_sim=n_sim, n_time=n_time, S0=S0, dt=dt)

  ST = S[-1, :]

  if type_ == 'C':
    payoffs = np.maximum(ST - K, 0.0)
  else:
    payoffs = np.maximum(K - ST, 0.0)

  O = np.exp(-r*T) * np.mean(payoffs)
  return O

list_price = []
for _ in range(100):
  price = get_monte_carlo_price(mu=r, sigma=sigma, n_sim=n_sim, n_time=time_in_days,
                                S0=S0, dt=dt, r=r, T=T, K=K, type_='C')
  list_price.append(price)

np.mean(list_price)

