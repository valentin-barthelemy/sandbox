# -*- coding: utf-8 -*-
"""Test garch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pFwpt6rHGkSxP000LPKpyYvP2PmnST8F
"""

import pandas as pd
import numpy as np

!pip install arch

from google.colab import files
files.upload()

df = pd.read_excel('asml stock h.xlsx')
df.head(10)

# Calculate daily returns
df['Returns'] = df['PX_LAST'].pct_change().dropna()

# Display the first few rows with the new 'Returns' column
display(df.head())

df['Dates'] = pd.to_datetime(df['Dates'], errors='coerce', dayfirst=True)
df.set_index('Dates', inplace=True)
df.head()

# Rescale returns
rescaled_returns = df['Returns'].dropna() * 100

"""# Task
Construire un modèle GARCH(1,1) sur les rendements d'une action en utilisant une approche de fenêtre glissante pour l'évaluation, après avoir divisé les données en ensembles d'entraînement et de test.

## Diviser les données

### Subtask:
Séparer les données de rendement en ensembles d'entraînement et de test.

**Reasoning**:
Divide the rescaled returns into training and test sets using an 80/20 split and store them in the specified variables.
"""

train_size = int(len(rescaled_returns) * 0.8)
train_data, test_data = rescaled_returns[:train_size], rescaled_returns[train_size:]

display(f'Training data size: {len(train_data)}')
display(f'Test data size: {len(test_data)}')

"""## Implémenter la fenêtre glissante

### Subtask:
Mettre en place une boucle ou une fonction pour itérer sur l'ensemble de test en utilisant une fenêtre glissante sur l'ensemble d'entraînement.

**Reasoning**:
Initialize a list to store predictions and set the initial window size for the rolling window approach. Then, start a loop to iterate through the test data to define the training window for each iteration.
"""

predictions = []
window_size = len(train_data)

for i in range(len(test_data)):
    train_window = rescaled_returns[:window_size + i]

"""## Ajuster le modèle garch

### Subtask:
Pour chaque fenêtre glissante, ajuster le modèle GARCH(1,1) sur les données de la fenêtre d'entraînement.

**Reasoning**:
Fit the GARCH(1,1) model on the training window within the rolling window loop and store the results.
"""

garch_model = arch_model(train_window, vol='Garch', p=1, q=1)
    results = garch_model.fit(disp='off')

"""## Effectuer des prédictions

### Subtask:
Utiliser le modèle ajusté pour prédire la volatilité de la période suivante dans l'ensemble de test.

**Reasoning**:
Using the fitted GARCH model for the current training window, predict the conditional variance for the next period in the test set and append it to the predictions list.
"""

forecast = results.forecast(horizon=1)
    predicted_variance = forecast.variance.iloc[-1, 0]
    predictions.append(predicted_variance)

"""## Évaluer les prédictions

### Subtask:
Comparer les prédictions de volatilité avec les rendements réels dans l'ensemble de test.

**Reasoning**:
Convert the predictions list to a pandas Series, calculate the standard deviation (volatility) from the predicted variance, and then display the head of both the predicted volatility series and the actual test data returns for initial comparison.
"""

predictions = []
window_size = len(train_data)

for i in range(len(test_data)):
    train_window = rescaled_returns[:window_size + i]
    garch_model = arch_model(train_window, vol='Garch', p=1, q=1, dist ='t')
    results = garch_model.fit(disp='off')
    forecast = results.forecast(horizon=1)
    predicted_variance = forecast.variance.iloc[-1, 0]
    predictions.append(predicted_variance)

predicted_volatility = pd.Series(np.sqrt(predictions), index=test_data.index)

display("Predicted Volatility (first 5 values):")
display(predicted_volatility.head())
display("Actual Test Data Returns (first 5 values):")
display(test_data.head())

"""**Reasoning**:
The predicted volatility and actual returns have been calculated and displayed. To further compare them, a visual comparison using a plot would be helpful.


"""

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
plt.plot(test_data.index, test_data.abs(), label='Actual Absolute Returns')
plt.plot(predicted_volatility.index, predicted_volatility, label='Predicted Volatility')
plt.title('Actual Absolute Returns vs Predicted Volatility (Test Set)')
plt.xlabel('Date Index')
plt.ylabel('Value')
plt.legend()
plt.show()

"""**Reasoning**:
The visual comparison plot has been generated. To complete the comparison, a statistical measure like the Root Mean Squared Error (RMSE) between the predicted volatility and the actual absolute returns would be useful.


"""

from sklearn.metrics import mean_squared_error

rmse = np.sqrt(mean_squared_error(test_data.abs(), predicted_volatility))
print(f"Root Mean Squared Error (RMSE) between actual absolute returns and predicted volatility: {rmse}")

"""## Visualiser les résultats

### Subtask:
Tracer la volatilité prédite et la comparer à la volatilité réelle (ou aux rendements) sur la période de test.

**Reasoning**:
Plot the actual absolute returns and the predicted volatility on the same graph to visually compare them.
"""

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
plt.plot(test_data.index, test_data.abs(), label='Actual Absolute Returns')
plt.plot(predicted_volatility.index, predicted_volatility, label='Predicted Volatility')
plt.title('Actual Absolute Returns vs Predicted Volatility (Test Set)')
plt.xlabel('Date Index')
plt.ylabel('Value')
plt.legend()
plt.show()

"""## Summary:

### Data Analysis Key Findings

*   The data was split into a training set of 1044 data points and a test set of 261 data points.
*   A GARCH(1,1) model was fitted within a rolling window framework on the training data to predict the one-step ahead volatility for the test set.
*   The predicted volatility values were compared visually against the actual absolute returns in the test set, showing that the predicted volatility generally follows the trends of the absolute returns.
*   The Root Mean Squared Error (RMSE) between the absolute actual returns and the predicted volatility was calculated as approximately 1.99, providing a quantitative measure of the prediction accuracy.

### Insights or Next Steps

*   Consider exploring other GARCH model orders (e.g., GARCH(1,2), GARCH(2,1), GARCH(2,2)) or alternative volatility models (e.g., EGARCH, TARCH) to see if they yield better prediction performance.
*   Investigate the impact of different window sizes for the rolling evaluation on the model's performance.

"""