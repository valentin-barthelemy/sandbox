# -*- coding: utf-8 -*-
"""Crank nicholson test pricing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1coTjCl1Qm-4efFF7IwPdNo8lm4g23DL9
"""

import numpy as np
from math import exp, log, sqrt
from scipy.stats import norm  # si tu n'as pas SciPy, remplace par une approx. de la N()

# --- Black–Scholes (pour vérifier) ---
def bs_call(S0, K, T, r, sigma):
    d1 = (log(S0/K) + (r + 0.5*sigma*sigma)*T) / (sigma*sqrt(T))
    d2 = d1 - sigma*sqrt(T)
    return S0*norm.cdf(d1) - K*exp(-r*T)*norm.cdf(d2)

# --- Solveur tridiagonal (Thomas) ---
def thomas_tridiag(a, b, c, d):
    # a: sous-diag (len n-1), b: diag (n), c: sur-diag (n-1), d: rhs (n)
    n = len(b)
    cp = np.empty(n-1); dp = np.empty(n)
    cp[0] = c[0] / b[0]
    dp[0] = d[0] / b[0]
    for i in range(1, n-1):
        denom = b[i] - a[i-1]*cp[i-1]
        cp[i] = c[i] / denom
        dp[i] = (d[i] - a[i-1]*dp[i-1]) / denom
    dp[n-1] = (d[n-1] - a[n-2]*dp[n-2]) / (b[n-1] - a[n-2]*cp[n-2])
    x = np.empty(n)
    x[-1] = dp[-1]
    for i in range(n-2, -1, -1):
        x[i] = dp[i] - cp[i]*x[i+1]
    return x

# --- Crank–Nicolson pour un call européen ---
def crank_nicolson_call(S0, K, T, r, sigma, Smax=4.0, N=200, M=200):
    """
    Smax: multiple du strike pour la borne haute (prix max ~ Smax*K)
    N: nb de points en S ; M: nb de pas de temps
    """
    Smax_val = Smax * K
    dS = Smax_val / N
    dt = T / M
    S = np.linspace(0, Smax_val, N+1)

    # condition terminale (payoff)
    C = np.maximum(S - K, 0.0)

    # coefficients i=1..N-1 (noeuds intérieurs)
    i = np.arange(1, N)
    sig2i2 = (sigma**2) * (i**2)
    ai = 0.25*dt*(sig2i2 - r*i)
    bi = -0.5*dt*(sig2i2 + r)
    ci = 0.25*dt*(sig2i2 + r*i)

    # Matrices tridiagonales A (gauche) et B (droite) implicites
    A_lower = -ai[1:]                 # (N-2)
    A_diag  = 1 - bi                  # (N-1)
    A_upper = -ci[:-1]                # (N-2)

    B_lower =  ai[1:]
    B_diag  = 1 + bi
    B_upper =  ci[:-1]

    # marche arrière dans le temps
    for n in range(M):
        # conditions de frontière à t = T - (n+1)*dt
        t_remain = T - (n+1)*dt
        C0 = 0.0                                    # call: C(0, t) = 0
        CN = Smax_val - K*exp(-r*t_remain)          # call: C(Smax, t) ~ S - K e^{-rτ}

        # RHS = B * C^{n+1}_int + ajustements frontière
        C_int = C[1:N]                               # (N-1)
        rhs = B_diag*C_int
        rhs[1:] += B_lower * C_int[:-1]
        rhs[:-1] += B_upper * C_int[1:]

        # ajuste frontières (colonne 0 et N) poussées dans le rhs
        rhs[0]  += ai[0]*C0
        rhs[-1] += ci[-1]*CN

        # résout A * C_int^{n} = rhs
        C[1:N] = thomas_tridiag(A_lower, A_diag, A_upper, rhs)
        # frontières actuelles (à t = T - (n+1)dt)
        C[0]  = C0
        C[-1] = CN

    # interpolation linéaire autour de S0 si S0 n'est pas sur la grille
    if S0 <= 0: return float(C[0])
    if S0 >= Smax_val: return float(C[-1])
    j = int(S0 // dS)
    w = (S0 - j*dS) / dS
    return float((1-w)*C[j] + w*C[j+1])

# --- Petit test ---
if __name__ == "__main__":
    S0, K, T, r, sigma = 100, 100, 1.0, 0.05, 0.60
    cn_price = crank_nicolson_call(S0, K, T, r, sigma, Smax=4.0, N=300, M=300)
    bs_price = bs_call(S0, K, T, r, sigma)
    print(f"Crank–Nicolson: {cn_price:.4f}  |  Black–Scholes: {bs_price:.4f}  |  erreur: {abs(cn_price-bs_price):.4e}")

